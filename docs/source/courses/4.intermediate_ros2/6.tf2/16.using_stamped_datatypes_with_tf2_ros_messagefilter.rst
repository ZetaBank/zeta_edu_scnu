tf2_ros::MessageFilter로 stamped 데이터 유형 사용하기
=======================================================

**목표:** stamped 데이터 유형을 처리하는 방법을 배우려면 ``tf2_ros::MessageFilter`` 를 사용합니다.

배경
----------

이 튜토리얼에서는 sensor 데이터를 tf2와 함께 사용하는 방법을 설명합니다.
sensor 데이터의 실제 예제로는 다음이 있습니다.

    * 카메라, 모노 및 스테레오

    * 레이저 스캔

새로운 터틀인 ``turtle3`` 이 생성되었으며 좋은 오도메트리 정보가 없지만 그 위치를 추적하고 ``world`` 프레임과 관련하여 ``PointStamped`` 메시지로 게시하는 오버헤드 카메라가 있습니다.

``turtle1`` 은 자신과 비교하여 ``turtle3`` 의 위치를 알고 싶습니다.

이를 위해 ``turtle1`` 은 ``turtle3`` 의 포즈가 게시되는 토픽을 청취하고 대상 프레임으로 변환할 수 있을 때까지 기다린 다음 작업을 수행해야 합니다.
이를 더 쉽게하기 위해  ``tf2_ros::MessageFilter`` 가 매우 유용합니다.
``tf2_ros::MessageFilter`` 는 헤더를 가진 모든 ROS 2 메시지에 대한 구독을 수행하고 해당 메시지를 대상 프레임으로 변환할 수 있을 때까지 캐싱합니다.

작업
-----

1 PointStamped 메시지 브로드캐스터 노드 작성
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

이 튜토리얼에서는 ``turtle3`` 의 ``PointStamped`` 위치 메시지를 게시하는 데 사용할 데모 응용 프로그램을 설정합니다.

먼저 소스 파일을 만들어 봅시다.

이전 튜토리얼에서 생성한 ``learning_tf2_py`` 패키지로 이동하십시오.
``src/learning_tf2_py/learning_tf2_py`` 디렉토리에서 다음 명령을 입력하여 예제 센서 메시지 브로드캐스터 코드를 다운로드합니다.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py


선호하는 텍스트 편집기로 파일을 엽니다.

.. code-block:: python

    from geometry_msgs.msg import PointStamped
    from geometry_msgs.msg import Twist

    import rclpy
    from rclpy.node import Node

    from turtlesim.msg import Pose
    from turtlesim.srv import Spawn


    class PointPublisher(Node):

        def __init__(self):
            super().__init__('turtle_tf2_message_broadcaster')

            # Create a client to spawn a turtle
            self.spawner = self.create_client(Spawn, 'spawn')
            # Boolean values to store the information
            # if the service for spawning turtle is available
            self.turtle_spawning_service_ready = False
            # if the turtle was successfully spawned
            self.turtle_spawned = False
            # if the topics of turtle3 can be subscribed
            self.turtle_pose_cansubscribe = False

            self.timer = self.create_timer(1.0, self.on_timer)

        def on_timer(self):
            if self.turtle_spawning_service_ready:
                if self.turtle_spawned:
                    self.turtle_pose_cansubscribe = True
                else:
                    if self.result.done():
                        self.get_logger().info(
                            f'Successfully spawned {self.result.result().name}')
                        self.turtle_spawned = True
                    else:
                        self.get_logger().info('Spawn is not finished')
            else:
                if self.spawner.service_is_ready():
                    # Initialize request with turtle name and coordinates
                    # Note that x, y and theta are defined as floats in turtlesim/srv/Spawn
                    request = Spawn.Request()
                    request.name = 'turtle3'
                    request.x = 4.0
                    request.y = 2.0
                    request.theta = 0.0
                    # Call request
                    self.result = self.spawner.call_async(request)
                    self.turtle_spawning_service_ready = True
                else:
                    # Check if the service is ready
                    self.get_logger().info('Service is not ready')

            if self.turtle_pose_cansubscribe:
                self.vel_pub = self.create_publisher(Twist, 'turtle3/cmd_vel', 10)
                self.sub = self.create_subscription(Pose, 'turtle3/pose', self.handle_turtle_pose, 10)
                self.pub = self.create_publisher(PointStamped, 'turtle3/turtle_point_stamped', 10)

        def handle_turtle_pose(self, msg):
            vel_msg = Twist()
            vel_msg.linear.x = 1.0
            vel_msg.angular.z = 1.0
            self.vel_pub.publish(vel_msg)

            ps = PointStamped()
            ps.header.stamp = self.get_clock().now().to_msg()
            ps.header.frame_id = 'world'
            ps.point.x = msg.x
            ps.point.y = msg.y
            ps.point.z = 0.0
            self.pub.publish(ps)


    def main():
        rclpy.init()
        node = PointPublisher()
        try:
            rclpy.spin(node)
        except KeyboardInterrupt:
            pass

        rclpy.shutdown()


1.1 코드 살펴보기
~~~~~~~~~~~~~~~~~~~~

이제 코드를 살펴보겠습니다.
먼저, ``on_timer`` 콜백 함수에서는 ``turtle3`` 을 비동기적으로 ``turtlesim`` 의 ``Spawn`` 서비스를 호출하여 생성하며, 터틀 생성 서비스가 준비되었을 때 그 위치를 (4, 2, 0)으로 초기화합니다.


.. code-block:: python

    # Initialize request with turtle name and coordinates
    # Note that x, y and theta are defined as floats in turtlesim/srv/Spawn
    request = Spawn.Request()
    request.name = 'turtle3'
    request.x = 4.0
    request.y = 2.0
    request.theta = 0.0
    # Call request
    self.result = self.spawner.call_async(request)

그 다음, 노드는 ``turtle3/cmd_vel`` 토픽, ``turtle3/turtle_point_stamped`` 토픽을 게시하고"``turtle3/pose`` 토픽을 구독하고 모든 수신 메시지에 ``handle_turtle_pose`` 콜백 함수를 실행합니다.

.. code-block:: python

    self.vel_pub = self.create_publisher(Twist, '/turtle3/cmd_vel', 10)
    self.sub = self.create_subscription(Pose, '/turtle3/pose', self.handle_turtle_pose, 10)
    self.pub = self.create_publisher(PointStamped, '/turtle3/turtle_point_stamped', 10)

마지막으로 ``handle_turtle_pose`` 콜백 함수에서는 ``turtle3`` 의 ``Twist`` 메시지를 초기화하고 게시하여 ``turtle3`` 을 원형으로 이동시킵니다.
그런 다음 들어오는 ``Pose`` 메시지로 ``turtle3`` 의 ``PointStamped`` 메시지를 채우고 게시합니다.

.. code-block:: python

    vel_msg = Twist()
    vel_msg.linear.x = 1.0
    vel_msg.angular.z = 1.0
    self.vel_pub.publish(vel_msg)

    point_msg = PointStamped()
    point_msg.header.stamp = self.get_clock().now().to_msg()
    point_msg.header.frame_id = 'world'
    point_msg.point.x = msg.x
    point_msg.point.y = msg.y
    point_msg.point.z = 0.0
    self.point_pub.publish(point_msg)

1.2 런치 파일 작성
~~~~~~~~~~~~~~~~~~~~~~~~~

이 데모를 실행하려면 ``learning_tf2_py`` 패키지의 ``launch`` 하위 디렉토리에 ``turtle_tf2_sensor_message.launch.py`` 런치 파일을 만들어야 합니다.

.. code-block:: python

    from launch import LaunchDescription
    from launch.actions import DeclareLaunchArgument
    from launch_ros.actions import Node


    def generate_launch_description():
        return LaunchDescription([
            DeclareLaunchArgument(
                'target_frame', default_value='turtle1',
                description='Target frame name.'
            ),
            Node(
                package='turtlesim',
                executable='turtlesim_node',
                name='sim',
                output='screen'
            ),
            Node(
                package='turtle_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster1',
                parameters=[
                    {'turtlename': 'turtle1'}
                ]
            ),
            Node(
                package='turtle_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster2',
                parameters=[
                    {'turtlename': 'turtle3'}
                ]
            ),
            Node(
                package='turtle_tf2_py',
                executable='turtle_tf2_message_broadcaster',
                name='message_broadcaster',
            ),
        ])


1.3 엔트리 포인트 추가
~~~~~~~~~~~~~~~~~~~~~~

``ros2 run`` 명령이 노드를 실행하도록 하려면 "setup.py" (``src/learning_tf2_py`` 디렉토리에 위치함)에 엔트리 포인트를 추가해야 합니다.

다음 줄을 ``'console_scripts':`` 괄호 사이에 추가하십시오.

.. code-block:: python

    'turtle_tf2_message_broadcaster = learning_tf2_py.turtle_tf2_message_broadcaster:main',

1.4 빌드
~~~~~~~~~

워크스페이스 루트에서 누락된 종속성을 확인하기 위해 "rosdep"를 실행합니다.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro humble -y


그런 다음 패키지를 빌드합니다.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

2 메시지 필터/리스너 노드 작성
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

이제, ``turtle3`` 의 스트리밍 ``PointStamped`` 데이터를 ``turtle1`` 의 프레임으로 신뢰성 있게 얻기 위해, 메시지 필터/리스너 노드의 소스 파일을 만들겠습니다.

이전 튜토리얼에서 만든 ``learning_tf2_cpp`` :doc:`패키지 <./3.writing_a_tf2_static_broadcaster_cpp>` 로 이동하세요.
``src/learning_tf2_cpp/src`` 디렉토리에서 다음 명령을 입력하여 파일 ``turtle_tf2_message_filter.cpp`` 을 다운로드합니다:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp


선호하는 텍스트 편집기를 사용하여 파일을 엽니다.

.. code-block:: C++

    #include <chrono>
    #include <memory>
    #include <string>

    #include "geometry_msgs/msg/point_stamped.hpp"
    #include "message_filters/subscriber.h"
    #include "rclcpp/rclcpp.hpp"
    #include "tf2_ros/buffer.h"
    #include "tf2_ros/create_timer_ros.h"
    #include "tf2_ros/message_filter.h"
    #include "tf2_ros/transform_listener.h"
    #ifdef TF2_CPP_HEADERS
      #include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"
    #else
      #include "tf2_geometry_msgs/tf2_geometry_msgs.h"
    #endif

    using namespace std::chrono_literals;

    class PoseDrawer : public rclcpp::Node
    {
    public:
      PoseDrawer()
      : Node("turtle_tf2_pose_drawer")
      {
        // Declare and acquire `target_frame` parameter
        target_frame_ = this->declare_parameter<std::string>("target_frame", "turtle1");

        std::chrono::duration<int> buffer_timeout(1);

        tf2_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
        // Create the timer interface before call to waitForTransform,
        // to avoid a tf2_ros::CreateTimerInterfaceException exception
        auto timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
          this->get_node_base_interface(),
          this->get_node_timers_interface());
        tf2_buffer_->setCreateTimerInterface(timer_interface);
        tf2_listener_ =
          std::make_shared<tf2_ros::TransformListener>(*tf2_buffer_);

        point_sub_.subscribe(this, "/turtle3/turtle_point_stamped");
        tf2_filter_ = std::make_shared<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>>(
          point_sub_, *tf2_buffer_, target_frame_, 100, this->get_node_logging_interface(),
          this->get_node_clock_interface(), buffer_timeout);
        // Register a callback with tf2_ros::MessageFilter to be called when transforms are available
        tf2_filter_->registerCallback(&PoseDrawer::msgCallback, this);
      }

    private:
      void msgCallback(const geometry_msgs::msg::PointStamped::SharedPtr point_ptr)
      {
        geometry_msgs::msg::PointStamped point_out;
        try {
          tf2_buffer_->transform(*point_ptr, point_out, target_frame_);
          RCLCPP_INFO(
            this->get_logger(), "Point of turtle3 in frame of turtle1: x:%f y:%f z:%f\n",
            point_out.point.x,
            point_out.point.y,
            point_out.point.z);
        } catch (const tf2::TransformException & ex) {
          RCLCPP_WARN(
            // Print exception which was caught
            this->get_logger(), "Failure %s\n", ex.what());
        }
      }

      std::string target_frame_;
      std::shared_ptr<tf2_ros::Buffer> tf2_buffer_;
      std::shared_ptr<tf2_ros::TransformListener> tf2_listener_;
      message_filters::Subscriber<geometry_msgs::msg::PointStamped> point_sub_;
      std::shared_ptr<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>> tf2_filter_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<PoseDrawer>());
      rclcpp::shutdown();
      return 0;
    }



2.1 코드 검토
~~~~~~~~~~~~~~~~~~~~

먼저, ``tf2_ros`` 패키지의 ``tf2_ros::MessageFilter`` 헤더를 포함해야하며, 이전에 사용한 ``tf2`` 및 ``ros2`` 관련 헤더도 포함해야합니다.

.. code-block:: C++

    #include "geometry_msgs/msg/point_stamped.hpp"
    #include "message_filters/subscriber.h"
    #include "rclcpp/rclcpp.hpp"
    #include "tf2_ros/buffer.h"
    #include "tf2_ros/create_timer_ros.h"
    #include "tf2_ros/message_filter.h"
    #include "tf2_ros/transform_listener.h"
    #ifdef TF2_CPP_HEADERS
      #include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"
    #else
      #include "tf2_geometry_msgs/tf2_geometry_msgs.h"
    #endif


두 번째로, ``tf2_ros::Buffer``, ``tf2_ros::TransformListener``, 및 ``tf2_ros::MessageFilter`` 의 지속적인 인스턴스가 있어야합니다.

.. code-block:: C++

    std::string target_frame_;
    std::shared_ptr<tf2_ros::Buffer> tf2_buffer_;
    std::shared_ptr<tf2_ros::TransformListener> tf2_listener_;
    message_filters::Subscriber<geometry_msgs::msg::PointStamped> point_sub_;
    std::shared_ptr<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>> tf2_filter_;


세 번째로, ROS 2의 ``message_filters::Subscriber`` 는 해당 토픽과 함께 초기화되어야 합니다.
그리고 ``tf2_ros::MessageFilter`` 는 이 ``Subscriber`` 객체로 초기화되어야 합니다.
``MessageFilter`` 생성자에서 주목해야 할 다른 인수들은 ``target_frame`` 과 콜백 함수입니다.
대상 프레임(target frame)은 ``canTransform`` 이 성공할 것으로 보장할 프레임입니다. 그리고 콜백 함수는 데이터가 준비되면 호출되는 함수입니다.


.. code-block:: C++

    PoseDrawer()
    : Node("turtle_tf2_pose_drawer")
    {
      // Declare and acquire `target_frame` parameter
      target_frame_ = this->declare_parameter<std::string>("target_frame", "turtle1");

      std::chrono::duration<int> buffer_timeout(1);

      tf2_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
      // Create the timer interface before call to waitForTransform,
      // to avoid a tf2_ros::CreateTimerInterfaceException exception
      auto timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
        this->get_node_base_interface(),
        this->get_node_timers_interface());
      tf2_buffer_->setCreateTimerInterface(timer_interface);
      tf2_listener_ =
        std::make_shared<tf2_ros::TransformListener>(*tf2_buffer_);

      point_sub_.subscribe(this, "/turtle3/turtle_point_stamped");
      tf2_filter_ = std::make_shared<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>>(
        point_sub_, *tf2_buffer_, target_frame_, 100, this->get_node_logging_interface(),
        this->get_node_clock_interface(), buffer_timeout);
      // Register a callback with tf2_ros::MessageFilter to be called when transforms are available
      tf2_filter_->registerCallback(&PoseDrawer::msgCallback, this);
    }


마지막으로, 데이터가 준비되면 콜백 메서드가 ``tf2_buffer_->transform`` 을 호출하고 콘솔에 출력합니다.

.. code-block:: C++

    private:
      void msgCallback(const geometry_msgs::msg::PointStamped::SharedPtr point_ptr)
      {
        geometry_msgs::msg::PointStamped point_out;
        try {
          tf2_buffer_->transform(*point_ptr, point_out, target_frame_);
          RCLCPP_INFO(
            this->get_logger(), "Point of turtle3 in frame of turtle1: x:%f y:%f z:%f\n",
            point_out.point.x,
            point_out.point.y,
            point_out.point.z);
        } catch (const tf2::TransformException & ex) {
          RCLCPP_WARN(
            // Print exception which was caught
            this->get_logger(), "Failure %s\n", ex.what());
        }
      }

2.2 종속성 추가
~~~~~~~~~~~~~~~~~~~~

``learning_tf2_cpp`` 패키지를 빌드하기 전에 패키지의 ``package.xml`` 파일에 두 가지 종속성을 추가하십시오.

.. code-block:: xml

    <depend>message_filters</depend>
    <depend>tf2_geometry_msgs</depend>

2.3 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

그리고 ``CMakeLists.txt`` 파일에서 기존 종속성 아래에 두 줄을 추가하십시오.

.. code-block:: console

    find_package(message_filters REQUIRED)
    find_package(tf2_geometry_msgs REQUIRED)

그 아래의 라인들은 ROS 배포 버전 간의 차이를 처리합니다.

.. code-block:: console

    if(TARGET tf2_geometry_msgs::tf2_geometry_msgs)
      get_target_property(_include_dirs tf2_geometry_msgs::tf2_geometry_msgs INTERFACE_INCLUDE_DIRECTORIES)
    else()
      set(_include_dirs ${tf2_geometry_msgs_INCLUDE_DIRS})
    endif()

    find_file(TF2_CPP_HEADERS
      NAMES tf2_geometry_msgs.hpp
      PATHS ${_include_dirs}
      NO_CACHE
      PATH_SUFFIXES tf2_geometry_msgs
    )

그런 다음 실행 파일을 추가하고 이름을 ``turle_tf2_message_filter`` 로 지정하면 나중에 ``ros2 run`` 과 함께 사용할 수 있습니다.

.. code-block:: console

    add_executable(turtle_tf2_message_filter src/turtle_tf2_message_filter.cpp)
    ament_target_dependencies(
      turtle_tf2_message_filter
      geometry_msgs
      message_filters
      rclcpp
      tf2
      tf2_geometry_msgs
      tf2_ros
    )

    if(EXISTS ${TF2_CPP_HEADERS})
      target_compile_definitions(turtle_tf2_message_filter PUBLIC -DTF2_CPP_HEADERS)
    endif()

마지막으로, ``install(TARGETS…)`` 섹션을 추가하십시오 (기존 노드 아래에) 이렇게 하면 ``ros2 run`` 에서 실행 가능한 파일을 찾을 수 있습니다.

.. code-block:: console

    install(TARGETS
      turtle_tf2_message_filter
      DESTINATION lib/${PROJECT_NAME})

2.4 빌드
~~~~~~~~~

작업 공간의 루트로 이동하여 누락된 종속성을 확인하려면 작업 공간의 루트에서 ``rosdep`` 를 실행합니다.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro humble -y

그런 다음 새 터미널을 열고 작업 공간의 루트로 이동하여 다음 명령을 사용하여 패키지를 다시 빌드합니다.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_cpp


새 터미널을 열고 작업 공간의 루트로 이동하여 설정 파일을 소스합니다.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          . install/setup.bash

3 실행
^^^^^

먼저 ``turtle_tf2_sensor_message.launch.py`` 라는 런치 파일을 실행하여 포인트 스탬프 메시지의 브로드캐스터 노드를 포함한 여러 노드를 실행해야 합니다.

.. code-block:: console

    ros2 launch learning_tf2_py turtle_tf2_sensor_message.launch.py

이 명령을 실행하면 ``turtlesim`` 창이 나타나며 두 마리의 거북이가 표시됩니다.
여기서 ``turtle3`` 는 원을 따라 움직이고, ``turtle1`` 은 처음에는 움직이지 않습니다.
그러나 다른 터미널에서 ``turtle_teleop_key`` 노드를 실행하여 ``turtle1`` 을 움직일 수 있습니다.

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

.. image:: images/turtlesim_messagefilter.png

이제 ``turtle3/turtle_point_stamped`` 토픽을 에코하면 다음과 같은 출력이 표시됩니다.

.. code-block:: console

    header:
      stamp:
        sec: 1629877510
        nanosec: 902607040
      frame_id: world
    point:
      x: 4.989276885986328
      y: 3.073937177658081
      z: 0.0
    ---
    header:
      stamp:
        sec: 1629877510
        nanosec: 918389395
      frame_id: world
    point:
      x: 4.987966060638428
      y: 3.089883327484131
      z: 0.0
    ---
    header:
      stamp:
        sec: 1629877510
        nanosec: 934186680
      frame_id: world
    point:
      x: 4.986400127410889
      y: 3.105806589126587
      z: 0.0
    ---

데모가 실행되는 동안 다른 터미널을 열고 메시지 필터/리스너 노드를 다음과 같이 실행합니다.

.. code-block:: console

    ros2 run learning_tf2_cpp turtle_tf2_message_filter

올바르게 실행 중이면 다음과 같은 스트리밍 데이터가 나타납니다.

.. code-block:: console

    [INFO] [1630016162.006173900] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.493231 y:-2.961614 z:0.000000

    [INFO] [1630016162.006291983] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.472169 y:-3.004742 z:0.000000

    [INFO] [1630016162.006326234] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.479420 y:-2.990479 z:0.000000

    [INFO] [1630016162.006355644] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.486441 y:-2.976102 z:0.000000

요약
-------

이 튜토리얼에서는 tf2에서 센서 데이터/메시지를 사용하는 방법을 배웠습니다.
구체적으로 말하자면, 어떻게 토픽에 ``PointStamped`` 메시지를 게시하고, 토픽을 듣고 ``tf2_ros::MessageFilter`` 를 사용하여 ``PointStamped`` 메시지의 프레임을 변환하는지를 배웠습니다.

