리스너 작성하기 (Python)
===========================

**목표:** tf2를 사용하여 프레임 변환에 액세스하는 방법을 배웁니다.

배경
----

이전 튜토리얼에서는 turtle의 포즈를 tf2에 발행하는 tf2 브로드캐스터를 생성했습니다.

이 튜토리얼에서는 tf2를 사용하기 위해 tf2 리스너를 생성합니다.

전제 조건
----------

이 튜토리얼은 이전의 :doc:`tf2 정적 브로드캐스터 튜토리얼 (Python) <./2.writing_a_tf2_static_broadcaster_py>` 및 :doc:`tf2 브로드캐스터 튜토리얼 (Python) <./4.writing_a_tf2_broadcaster_py>` 을 완료했다고 가정합니다.
이전 튜토리얼에서는 ``learning_tf2_cpp`` 패키지를 생성했으며 여기에서 계속 작업합니다.

작업
-----

1. 리스너 노드 작성
^^^^^^^^^^^^^^^^^^^^^^^^^

먼저 소스 파일을 작성합시다.
이전 튜토리얼에서 생성한 ``learning_tf2_py`` 패키지로 이동합니다.
``src/learning_tf2_py/learning_tf2_py`` 디렉토리 안으로 들어가 다음 명령어를 입력하여 예제 리스너 코드를 다운로드합니다.

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_listener.py


선호하는 텍스트 편집기로 파일을 엽니다.

.. code-block:: python

    import math

    from geometry_msgs.msg import Twist

    import rclpy
    from rclpy.node import Node

    from tf2_ros import TransformException
    from tf2_ros.buffer import Buffer
    from tf2_ros.transform_listener import TransformListener

    from turtlesim.srv import Spawn


    class FrameListener(Node):

        def __init__(self):
            super().__init__('turtle_tf2_frame_listener')

            # Declare and acquire `target_frame` parameter
            self.target_frame = self.declare_parameter(
              'target_frame', 'turtle1').get_parameter_value().string_value

            self.tf_buffer = Buffer()
            self.tf_listener = TransformListener(self.tf_buffer, self)

            # Create a client to spawn a turtle
            self.spawner = self.create_client(Spawn, 'spawn')
            # Boolean values to store the information
            # if the service for spawning turtle is available
            self.turtle_spawning_service_ready = False
            # if the turtle was successfully spawned
            self.turtle_spawned = False

            # Create turtle2 velocity publisher
            self.publisher = self.create_publisher(Twist, 'turtle2/cmd_vel', 1)

            # Call on_timer function every second
            self.timer = self.create_timer(1.0, self.on_timer)

        def on_timer(self):
            # Store frame names in variables that will be used to
            # compute transformations
            from_frame_rel = self.target_frame
            to_frame_rel = 'turtle2'

            if self.turtle_spawning_service_ready:
                if self.turtle_spawned:
                    # Look up for the transformation between target_frame and turtle2 frames
                    # and send velocity commands for turtle2 to reach target_frame
                    try:
                        t = self.tf_buffer.lookup_transform(
                            to_frame_rel,
                            from_frame_rel,
                            rclpy.time.Time())
                    except TransformException as ex:
                        self.get_logger().info(
                            f'Could not transform {to_frame_rel} to {from_frame_rel}: {ex}')
                        return

                    msg = Twist()
                    scale_rotation_rate = 1.0
                    msg.angular.z = scale_rotation_rate * math.atan2(
                        t.transform.translation.y,
                        t.transform.translation.x)

                    scale_forward_speed = 0.5
                    msg.linear.x = scale_forward_speed * math.sqrt(
                        t.transform.translation.x ** 2 +
                        t.transform.translation.y ** 2)

                    self.publisher.publish(msg)
                else:
                    if self.result.done():
                        self.get_logger().info(
                            f'Successfully spawned {self.result.result().name}')
                        self.turtle_spawned = True
                    else:
                        self.get_logger().info('Spawn is not finished')
            else:
                if self.spawner.service_is_ready():
                    # Initialize request with turtle name and coordinates
                    # Note that x, y and theta are defined as floats in turtlesim/srv/Spawn
                    request = Spawn.Request()
                    request.name = 'turtle2'
                    request.x = float(4)
                    request.y = float(2)
                    request.theta = float(0)
                    # Call request
                    self.result = self.spawner.call_async(request)
                    self.turtle_spawning_service_ready = True
                else:
                    # Check if the service is ready
                    self.get_logger().info('Service is not ready')


    def main():
        rclpy.init()
        node = FrameListener()
        try:
            rclpy.spin(node)
        except KeyboardInterrupt:
            pass

        rclpy.shutdown()

1.1 코드 검토
~~~~~~~~~~~~~~~~~~~~

터틀을 생성하는 서비스에 대한 작동 방식을 이해하려면 :doc:`간단한 서비스 및 클라이언트 작성하기 (Python) </courses/3.tutorial_client_libraries/7.writing_a_simple_py_service_and_client>` 튜토리얼을 참조하십시오.

이제 프레임 변환에 액세스하는 데 관련된 코드를 살펴봅시다.
``tf2_ros`` 패키지는 변환 수신 작업을 쉽게 하기 위해 ``TransformListener`` 를 구현했습니다.

.. code-block:: python

    from tf2_ros.transform_listener import TransformListener

여기서 ``TransformListener`` 객체를 생성합니다.
한번 리스너가 생성되면 tf2 변환을 수신하기 시작하고 최대 10초 동안 버퍼링합니다.

.. code-block:: python

    self.tf_listener = TransformListener(self.tf_buffer, self)

마지막으로 특정 변환을 조회합니다.
``lookup_transform`` 메서드를 다음 인수와 함께 호출합니다:

#. 대상 프레임

#. 소스 프레임

#. 변환을 조회하려는 시간

``rclpy.time.Time()`` 을 제공하면 최신 사용 가능한 변환을 얻게됩니다.
이 모든 것은 가능한 예외를 처리하기 위해 try-except 블록으로 래핑되어 있습니다.

.. code-block:: python

    t = self.tf_buffer.lookup_transform(
        to_frame_rel,
        from_frame_rel,
        rclpy.time.Time())

1.2 진입 지점 추가
~~~~~~~~~~~~~~~~~~~~~~

``ros2 run`` 명령어로 노드를 실행하려면 ``setup.py`` (``src/learning_tf2_py`` 디렉토리에 위치함)에 진입 지점을 추가해야 합니다.

다음 라인을 ``'console_scripts':`` 괄호 안에 추가합니다.

.. code-block:: python

    'turtle_tf2_listener = learning_tf2_py.turtle_tf2_listener:main',

2. 런치 파일 업데이트
^^^^^^^^^^^^^^^^^^^^^^^^

텍스트 편집기로 ``turtle_tf2_demo.launch.py`` 라는 런치 파일을 열고, 런치 설명에 두 개의 새 노드를 추가하고 런치 인수를 추가하며 import 문을 추가합니다.
결과 파일은 다음과 같아야 합니다.

.. code-block:: python

    from launch import LaunchDescription
    from launch.actions import DeclareLaunchArgument
    from launch.substitutions import LaunchConfiguration

    from launch_ros.actions import Node


    def generate_launch_description():
        return LaunchDescription([
            Node(
                package='turtlesim',
                executable='turtlesim_node',
                name='sim'
            ),
            Node(
                package='learning_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster1',
                parameters=[
                    {'turtlename': 'turtle1'}
                ]
            ),
            DeclareLaunchArgument(
                'target_frame', default_value='turtle1',
                description='Target frame name.'
            ),
            Node(
                package='learning_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster2',
                parameters=[
                    {'turtlename': 'turtle2'}
                ]
            ),
            Node(
                package='learning_tf2_py',
                executable='turtle_tf2_listener',
                name='listener',
                parameters=[
                    {'target_frame': LaunchConfiguration('target_frame')}
                ]
            ),
        ])


이것은 ``target_frame`` 런치 인수를 선언하고, 두 번째로 생성할 터틀을 시작하며 해당 변환을 구독할 리스너를 시작합니다.

3. 빌드
^^^^^^^

워크스페이스의 루트에서 빠진 종속성을 확인하려면 ``rosdep`` 를 실행합니다.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y


워크스페이스의 루트에서 패키지를 빌드합니다.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

새 터미널을 열고 워크스페이스 루트로 이동하여 설정 파일을 소스합니다.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        . install/setup.bash


4. 실행
^^^^^

이제 터틀 데모를 실행할 준비가 되었습니다.

.. code-block:: console

    ros2 launch learning_tf2_py turtle_tf2_demo.launch.py

두 개의 터틀이 있는 터틀 시뮬레이터를 볼 수 있어야 합니다.
두 번째 터미널 창에서 다음 명령을 입력합니다.

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

모든 것이 제대로 작동하는지 확인하려면 첫 번째 터틀을 화살표 키로 조작하여 두 번째 터틀이 첫 번째 터틀을 따라가는 것을 볼 수 있습니다!

요약
-------

이 튜토리얼에서는 tf2를 사용하여 프레임 변환에 액세스하는 방법을 배웠습니다.
또한 :doc:`tf2 소개 <./1.introduction_to_tf2>` 튜토리얼에서 처음 시도한 자체 turtlesim 데모를 작성하는 것을 완료했습니다.
