개념 설명
=============================================

Zetabot 로봇 내에서는 ROS(Robot Operating System)를 사용하여 로봇을 제어하고 통신합니다.

ROS 내에서 Topic과 Node가 무엇인지, 해당 Topic을 노드로 게시하고 구독하는 방법을 살펴보았다면 일반적인 ROS Command Line과 Service Server 및 Client 상호 작용을 살펴보겠습니다.


ROS Command Line  
------------------

1. ``rosnode`` command line 도구
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``rosnode`` 는 ROS 노드에 대한 정보를 표시할 수 있는 명령입니다. 도구에 지원되는 명령어가 몇 가지 존재합니다.

- ``rosnode info``: 노드에 대한 정보를 인쇄합니다.. For example: ``rosnode info /node_name``는 **publication** and **subscription**을 포함하여 노드에 대한 정보를 표시합니다.
- ``rosnode kill``: 실행 중인 노드를 종료합니다. 리스폰 되도록 설정된 노드는 죽지 않거나 다시 나타나기 때문에 주의가 필요합니다. 

  - 노드 이름으로 하나 이상의 노드를 종료합니다.
    
    .. code-block:: bash

      $ rosnode kill rosout add_two_ints_server add_threeints_server ...
  
  - 사용자 입력으로 노드 종료 (대화형 모드):

    .. code-block:: bash

      $ rosnode kill 
      1. /rosout
      
      Please enter the number of the node you wish to kill.
      > 

  - 모든 노드를 종료합니다.
    
    ``kill -a, kill --all``

- ``rosnode list``: 활성 노드 나열

  - 현재 노드 목록을 표시합니다.

    .. code-block:: bash

      $ rosnode list
  
  - /namespace_topic 내의 모든 현재 목록을 표시합니다.
    
    .. code-block:: bash

      $ rosnode list /example_topic_name

  - XML -RPC URI를 표시하려면 다음을 수행하세요.
  
    .. code-block:: bash

      $ rosnode list -u
  
  - 모든 현재 노드( ``-a`` 또는 ``--all``)의 이름과 XML -RPC UIR를 표시하려면
  
    .. code-block:: bash

      $ rosnode list -a

  
- ``rosnode machine``: 특정 머신에서 실행 중인 노드를 나열하거나 머신을 나열합니다. 예를 들어 Zetabot에서 실행 중인 노드를 보려면 다음을 수행하세요.
  
  .. code-block:: bash

    $ rosnode machine zetabot.local
    /talker-zetabot.local-72266-1257921234733
    /rosout
    /listener-zetabot.local-72615-1257921238320

- ``rosnode The rostopic command-line tool displays information about ROS topics. Currently, it can display a list of active topics, the publishers and subscribers of a specific topic, the publishing rate of a topic, the bandwidth of a topic, and messages published to a topic. The display of messages is configurable to output in a plotting-friendly format.ping``: 반복적으로 핑을 보내 노드에 대한 연결을 테스트합니다.. 
  - ``rosnode ping /node_name`` 또는 ``rosnode ping --all``를 이용하여 노드 이름을 지정하거나 모든 노드를 ping 하여 개별적으로 또는 전체적으로 노드를 ping 할 수 있습니다.
  - 개별 노드를 Count 횟수만큼 ping 할 수도 있습니다.
    
    .. code-block:: bash

      $ rosnode ping -c 4 rosout
      rosnode: node is [/rosnode]
      pinging /rosout with a timeout of 3.0s
      xmlrpc reply from http://ann:46635/     time=1.195908ms
      xmlrpc reply from http://ann:46635/     time=1.123905ms
      xmlrpc reply from http://ann:46635/     time=1.144886ms
      xmlrpc reply from http://ann:46635/     time=1.137018ms
      ping average: 1.150429ms

- ``rosnode clearnup``: 도달할 수 없는 노드의 등록 정보를 제거합니다. 이 기능은 ros 노드 표시를 위한 미용 솔루션으로 추가된 기능이므로 기능적 수단으로 사용해서는 안 됩니다. 
단순히 지연으로 인해 작동 중인 노드가 종료될 수도 있기 때문입니다.



2. ``rostopic`` command line 도구
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


rostopic 명령줄 도구는 ROS Topic에 대한 정보를 표시합니다. 현재는 활성 토픽 목록, 특정 토픽의 게시자 및 구독자, 토픽 게시 속도, 토픽 대역폭, 토픽에 게시된 메시지를 표시할 수 있습니다. 메시지 표시는 플로팅에 적합한 형식으로 출력되도록 구성할 수 있습니다.

- ``rostopic list`` 모든 현재 토픽을 표시합니다. 
  - To recieve information on a specific topic, use the ``rostopic list /topic_name`` command. This is equivalent to ``rostopic info `` command. 
  - If you wish to save the topic lists in a bag file, add ``-b`` argument.
  - If you wish to only list the publishers of the said topic, add ``-p`` argument. 
  - If you wish to only list the subscribers of the said topic, add  ``-s`` argument. 
  - You may also control the display output, by adding ``-v`` verbose argument. 

- ``rostopic echo`` displays the messages sent to a topic. 
  - In order to specify which topic, add the topic name after the command line: 
    
    .. code-block:: bash

      $ rostopic echo /imu
  
3. ``pm2`` command line tool
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``pm2`` is a deamon process manager that helps the management of application and nodes within the system. For our application we can type

.. code-block:: bash

  $ pm2 list


ROS Service
----------------


As we learned, the publish / subscribe model is a very flexible communication paradigm but it does not allow request / reply based interactions. 
Big example for this is sensors that has to recieve and send feedback inforamtions, rather than publishing every sensed information. We can implement
request / reply based communication system with *Service* which is defined by a pair of messages; one for the request and one for the reply. 

A providing ROS node offers a service under a string name, and a client calls the service by sending the request message and awaiting the reply. 

As mentioned earlier the ROS Services are defined by srv (simplified service description language) files. With the usage of rospy (python library),
we can convert the srv files into Python source code, and create three classes necessary for ROS Services:

1. Service Definition. Ex: (my_package/srv/Foo.srv -> my_package.srv.Foo)
   
   Within a python file, the Service is defined as a container for the request and response type. It must be used whenever one creates or calls a service

   .. code-block:: python 

    add_two_ints = rospy.ServiceProxy('service_name', my_package.srv.Foo)

2. Request Messages. Ex: (my_package/srv/Foo.srv -> my_package.srv.FooRequest)
   
   The resuest message is used to call the appropriate service. 


3. Response Messages. Ex: (my_package/srv/Foo.srv -> my_package.srv.FooResponse)

   The response message is used to contain the return value from the appropriate service. Hecne the Service handlers must return response messages instances of the correct type. 
  

2. Service proxies
^^^^^^^^^^^^^^^^^^^^^^^^

In most cases, you wish to set up a ``rospy.wait_for_service('service_name', timeout=None)`` to block until a service is available. 

In order to use a Service, we need to create a ``rospy.ServiceProxy(name, service_class, persistent=False, headers=None)`` with the name of the service one wishes to call. The Service may return an error
in which case, we need to have a exception handler. 

.. code-block:: python 

  rospy.wait_for_service('add_two_ints')
  try:
      add_two_ints = rospy.ServiceProxy('add_two_ints', AddTwoInts)
      resp1 = add_two_ints(x, y)
      return resp1.sum
  except rospy.ServiceException as e:
      print("Service call failed: %s"%e)

3. Calling services
^^^^^^^^^^^^^^^^^^^^^^^^

The ``rospy.ServiceProxy`` instances are callable. Within the python environment, you may call upon these instances similar to how a methos is called.

.. code-block:: python

  add_two_ints = rospy.ServiceProxy('add_two_ints', AddTwoInts)
  add_two_ints(1, 2)

There are total of three ways to pass an argument to the ServiceProxy instance.

1. Explicit style:
   
   The explicit style allows you to crewate your won * Request instance and pass it to publish. e.g:

   .. code-block:: python 

    request = rospy_tutorials.srv.AddTwoIntsRequest(1, 2)
    response = add_two_ints(request)

2. Implicit style with in-order arguments:
   
   In the in-order style, a new Message instance will be created with the arguments provided, in order. With this style, all of the fields must be provided. 

   .. code-block:: python 

    resp = add_two_ints(1, 2)

3. Implicit style with keyword arguments:

   In the keyword style, you can only initialize the fields you wish to put into as a Message. 

   .. code-block:: python 

    resp = add_two_ints(a = 1)

   The above code will set the a as 1 and b as the default value (for our case it is 0)

4. Providing Services
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In rospy, the rospy.Service instance with a callback to invoke when new requests are recieved is created to provide Service. Each inbound request is handled in its own thread,
so services must be **thread-safe**.

``rospy.Service(name, service_class, handler, buff_size=65536)``

- Create a new ROS Service with 
  - Specified name
  - Service type
  - Handler

    The handler is invoked with the service request and should invoke appropriate service response message. 

    .. code-block:: python 

      def add_two_ints(req):
        return rospy_tutorials.srv.AddTowIntsResponse(req.a + req.b)

      def add_two_ints_server():
        rospy.init_node('add_two_ints_server')
        s = rospy.Service('add_two_ints', rospy_tutorials.srv.AddTwoInts, add_two_ints)
        rospy.spin()

    The handler return type may be:

    - None(failure)
    - ServiceResponse
    - tuple or list
    - dict
    - singe-arugment responses only: value of fields.