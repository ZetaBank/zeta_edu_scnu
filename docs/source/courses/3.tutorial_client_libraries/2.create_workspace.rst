작업 공간 생성
====================

**목표:** 작업 공간을 생성하고 개발 및 테스트용 오버레이를 설정하는 방법을 배우세요.

배경 지식
----------

작업 공간은 ROS 2 패키지를 포함하는 디렉터리입니다.
ROS 2를 사용하기 전에 작업하려는 터미널에서 ROS 2 설치 작업 공간을 소스화해야 합니다.
이렇게 하면 ROS 2의 패키지가 해당 터미널에서 사용할 수 있게 됩니다.

또한 "오버레이"라는 것을 소스할 수 있는 옵션이 있습니다. 오버레이는 새로운 패키지를 추가할 수 있는 보조 작업 공간으로서, 기존의 ROS 2 확장 작업 공간 또는 "언더레이"와 간섭하지 않고 사용할 수 있습니다.
언더레이는 오버레이의 모든 패키지의 종속성을 포함해야 합니다.
오버레이의 패키지는 언더레이의 패키지를 덮어씁니다.
또한 언더레이와 오버레이 간에 여러 개의 계층을 가질 수 있으며, 각 연속적인 오버레이는 부모 언더레이의 패키지를 사용합니다.


전제 조건
-------------

* :doc:`ROS 2 설치 </courses/1.install_ros2_humble/3.install_ros2>`
* :doc:`colcon 설치 </courses/3.tutorial_client_libraries/1.colcon>`
* `git 설치 <https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>`__
* :doc:`turtlesim 설치 </courses/2.tutorial_cli_ros2/2.turtlesim_rqt>`
* :doc:`rosdep 설치 </courses/4.intermediate_ros2/1.rosdep>` 이 설치되어 있어야 합니다.
* 기본 터미널 명령어 이해 (`Linux에 대한 가이드 <https://www2.cs.sfu.ca/~ggbaker/reference/unix/>`__)
* 원하는 텍스트 편집기

작업 내용
---------

1. ROS 2 환경 소스화
^^^^^^^^^^^^^^^^^^^^^^^^^^

이 튜토리얼에서는 주로 ROS 2 설치 작업 공간을 언더레이로 사용합니다.
(언더레이는 주요 ROS 2 설치 작업 공간이 아니어도 됩니다.)

ROS 2를 어떻게 설치했는지(원본 빌드 또는 이진 파일에서) 및 사용 중인 플랫폼에 따라 정확한 소스 명령어가 다를 수 있습니다:

.. code-block:: console

    source /opt/ros/humble/setup.bash

만약 이 명령어가 작동하지 않는다면, 사용한 설치 가이드의 :doc:`설치 가이드 </courses/1.install_ros2_humble/3.install_ros2>` 를 참고하세요.

2. 새 디렉터리 생성
^^^^^^^^^^^^^^^^^^^^^^^^

최선의 실천 방법은 새로운 작업 공간마다 새 디렉터리를 만드는 것입니다.
디렉터리 이름은 중요하지 않지만, 작업 공간의 목적을 나타내는 것이 도움이 됩니다.
"개발 작업 공간"을 나타내기 위해 디렉터리 이름을 ``ros2_ws`` 로 선택해 보겠습니다.

.. code-block:: console

    mkdir -p ~/ros2_ws/src
    cd ~/ros2_ws/src


또 다른 최선의 실천 방법은 작업 공간의 모든 패키지를 ``src`` 디렉터리에 넣는 것입니다.
위의 코드는 ``ros2_ws`` 내에 ``src`` 디렉터리를 생성한 다음 해당 디렉터리로 이동합니다.


3. 샘플 리포지토리 복제
^^^^^^^^^^^^^^^^^^^^^^^^^

``ros2_ws/src`` 디렉터리에 있는지 확인한 후에 복제합니다.

초보 개발자 튜토리얼의 나머지 부분에서는 직접 패키지를 만들겠지만, 현재는 기존 패키지를 사용하여 작업 공간을 구성하는 연습을 할 것입니다.

:doc:`초보자: CLI 도구 </courses/2.tutorial_cli_ros2/0.index>` 튜토리얼을 진행했다면 `ros_tutorials <https://github.com/ros/ros_tutorials/>`__ 중 하나인 ``turtlesim`` 을 알게 될 것입니다.

리포지토리는 여러 브랜치를 가질 수 있습니다.
설치된 ROS 2 배포판을 대상으로 하는 브랜치를 확인해야 합니다.
이 리포지토리를 복제할 때 해당 브랜치를 추가하려면 ``-b`` 인수 다음에 해당 브랜치를 추가하십시오.

``ros2_ws/src`` 디렉터리에서 다음 명령어를 실행합니다.

.. code-block:: console

  git clone https://github.com/ros/ros_tutorials.git -b humble

이제 ``ros_tutorials`` 가 작업 공간에 복제되었습니다. ``ros_tutorials`` 리포지토리에는 이 튜토리얼의 나머지 부분에서 사용할 ``turtlesim`` 패키지가 포함되어 있습니다. 이 리포지토리의 다른 패키지는 ``COLCON_IGNORE`` 파일이 포함되어 있기 때문에 빌드되지 않습니다.

지금까지 샘플 패키지로 작업 공간을 채웠지만 아직 완전히 작동하는 작업 공간은 아닙니다.
먼저 종속성을 해결하고 작업 공간을 빌드해야 합니다.


4. 패키지 종속성 해결
^^^^^^^^^^^^^^^^^^^^^^

작업 공간을 빌드하기 전에 패키지 종속성을 해결해야 합니다.
이미 모든 종속성을 가지고 있을 수 있지만, 모든 복제마다 종속성을 확인하는 것이 최선의 실천 방법입니다.
오랜 기다림 끝에 빌드가 실패하고 종속성이 누락되었다는 것을 깨달을 수 있는 것은 원치 않을 것입니다.

작업 공간의 루트(``ros2_ws``)에서 다음 명령어를 실행합니다.



.. code-block:: bash

    # "src" 디렉터리와 함께 "ros_tutorials" 복제 디렉터리에 있으면
    cd ..
    rosdep install -i --from-path src --rosdistro humble -y


이미 모든 종속성을 가지고 있다면 콘솔에서 다음과 같은 메시지가 반환됩니다.

.. code-block:: console

  # All required rosdeps installed successfully

패키지는 패키지.xml 파일에서 종속성을 선언합니다 (패키지에 대한 자세한 내용은 다음 튜토리얼에서 알아보게 될 것입니다).
이 명령은 해당 선언을 통과하고 누락된 것을 설치합니다.
``rosdep`` 에 대해 자세히 알아보려면 다른 튜토리얼(곧 제공됨)을 참조하세요.

5. colcon으로 작업 공간 빌드
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

작업 공간의 루트(``ros2_ws``)에서 다음 명령을 사용하여 패키지를 빌드할 수 있습니다:



.. code-block:: console

    colcon build


콘솔에서 다음과 같은 메시지가 반환됩니다.

.. code-block:: console

  Starting >>> turtlesim
  Finished <<< turtlesim [5.49s]

  Summary: 1 package finished [5.58s]

.. note::

  ``colcon build`` 에 대한 유용한 인수들:

  * ``--packages-up-to``: 원하는 패키지 및 해당 종속성만 빌드하며 전체 작업 공간을 빌드하지 않습니다(시간을 절약합니다).
  * ``--symlink-install``: python 스크립트를 조정할 때마다 다시 빌드할 필요가 없습니다.
  * ``--event-handlers console_direct+``: 빌드 중에 콘솔 출력을 표시합니다(그렇지 않으면 ``log`` 디렉터리에서 찾을 수 있음).

빌드가 완료되면 작업 공간 루트(``~/ros2_ws``)에서 다음 명령을 입력하세요:


.. code-block:: console

    ls


그러면 colcon이 새로운 디렉터리를 생성한 것을 볼 수 있습니다:

.. code-block:: console

  build  install  log  src

``install`` 디렉터리는 작업 공간의 설정 파일이 있는 곳이며, 오버레이를 소스화하는 데 사용할 수 있습니다.


6. 오버레이 소스화
^^^^^^^^^^^^^^^^^^^^

오버레이를 소스하기 전에 매우 중요한 점은 작업 공간을 빌드한 터미널과 별도의 새 터미널을 열어야 합니다.
오버레이를 빌드한 터미널에서 오버레이를 소스하거나, 소스가 있는 터미널에서 빌드하면 복잡한 문제가 발생할 수 있습니다.

새 터미널에서 주 ROS 2 환경을 언더레이로 소스화하여 오버레이를 그 위에 "놓을" 수 있도록 하세요:

.. code-block:: console

    source /opt/ros/humble/setup.bash


작업 공간 루트로 이동하세요:


.. code-block:: console

    cd ~/ros2_ws


루트에서 오버레이를 소스하세요:


.. code-block:: console

    source install/local_setup.bash



.. note::

  오버레이의 ``local_setup`` 을 소스하는 것은 환경의 사용 가능한 패키지를 추가합니다.
  ``setup`` 은 오버레이와 해당 언더레이를 소스하므로 두 작업 공간을 모두 활용할 수 있게 됩니다.

  따라서 주 ROS 2 설치의 ``setup`` 을 소스하고 나서 오버레이 ``ros2_ws``의 ``local_setup`` 을 소스하는 것은, 그것이 언더레이 환경을 포함하므로, 그냥 ``ros2_ws`` 의 ``setup`` 을 소스하는 것과 동일합니다.

이제 오버레이에서 ``turtlesim`` 패키지를 실행할 수 있습니다:

.. code-block:: console

  ros2 run turtlesim turtlesim_node

그러나 이것이 오버레이 turtlesim이 실행되고 주요 설치의 turtlesim이 아닌 것을 어떻게 알 수 있을까요?

오버레이에서 효과를 볼 수 있도록 오버레이에서 turtlesim을 수정해 보겠습니다:

* 오버레이에서 패키지를 수정하고 다시 빌드할 수 있습니다.
* 오버레이는 언더레이를 덮어쓰므로 오버레이가 우선합니다.


7. 오버레이 수정
^^^^^^^^^^^^^^^^^^^^

오버레이에서 ``turtlesim`` 의 타이틀 바를 수정하여 수정할 수 있습니다.
``turtle_frame.cpp`` 파일을 찾아보세요. 이 파일은 ``turtlesim`` 패키지의 ``ros_tutorials/turtlesim/src`` 디렉터리에 있습니다.
선호하는 텍스트 편집기로 ``turtle_frame.cpp`` 파일을 엽니다.

라인 52에서 ``setWindowTitle("TurtleSim");`` 함수를 찾을 수 있습니다.
값 ``TurtleSim`` 을 ``MyTurtleSim`` 로 변경한 후 파일을 저장하세요.

이전에 ``colcon build`` 를 실행한 첫 번째 터미널로 돌아가 다시 실행하세요.

오버레이가 소스되어 있는 두 번째 터미널로 돌아가 "turtlesim"을 다시 실행하세요:

.. code-block:: console

  ros2 run turtlesim turtlesim_node

이제 "turtlesim" 창의 타이틀 바에 "MyTurtleSim"이라고 표시됩니다.

.. image:: /_images/create_workspace/overlay.png

오버레이의 수정 사항이 언더레이에 있는 것에는 영향을 미치지 않았음을 볼 수 있습니다.

언더레이가 여전히 유지되었는지 확인하려면 새 터미널을 열고 ROS 2 설치만 소스하십시오.
다시 "turtlesim"을 실행하세요:

.. code-block:: console

  ros2 run turtlesim turtlesim_node


.. image:: /_images/create_workspace/underlay.png

언더레이의 수정 사항이 실제로 언더레이에 아무런 영향을 미치지 않음을 볼 수 있습니다.


요약
-------
이 튜토리얼에서는 주요 ROS 2 배포판 설치를 언더레이로 소스하고 새로운 작업 공간에서 패키지를 복제하고 빌드하여 오버레이를 만드는 방법을 배웠습니다.
오버레이는 경로 앞에 추가되며 수정된 turtlesim을 통해 확인한 대로 언더레이보다 우선합니다.

오버레이를 사용하면 일부 패키지만 작업하고 모든 작업 공간을 동일한 곳에 넣고 모든 반복마다 거대한 작업 공간을 다시 빌드할 필요가 없으므로 추천됩니다.


다음 단계
---------

이제 작업 공간을 만들고 빌드하고 자신의 패키지를 만드는 방법을 이해했으므로 :doc:`자신만의 패키지 <./3.create_package>` 를 만드는 방법을 배울 수 있습니다.
